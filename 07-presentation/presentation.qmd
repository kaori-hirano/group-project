---
title: "Presentation"
author: "Kaori Hirano, Alicia Nguyen, James Xia"
format: 
  revealjs:
    embed-resources: true
    theme: "serif" 
---
```{r load-packages, echo = FALSE}
library(readr)
library(readxl)
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(dplyr))
library(patchwork)
suppressPackageStartupMessages(library(glmnet)) # for ridge, Lasso
suppressPackageStartupMessages(library(randomForest))
suppressPackageStartupMessages(library(caret))
library(Matrix)
library(broom)
library(tree)
library(tibble)
library(plotly)
library(rempsyc)
```
```{r merge-datasets}
wh_2023 <- read_excel("/cloud/project/data/wh_2023.xls")
load("/cloud/project/data/vdemdata-master/data/vdem.RData")
## load the original datasets

need_vdem=c("country_name","year","v2csreprss",'e_civil_war',"e_pt_coup",
            "v2x_partipdem","e_peaveduc","v2x_corr","v2x_cspart","v2xcs_ccsi",
            'e_regionpol')
vdem_use=vdem[,need_vdem]
need_wh=c("Country name","year","Social support","Freedom to make life choices",
          "Generosity","Life Ladder","Healthy life expectancy at birth",
          "Log GDP per capita")
wh_use=wh_2023[,need_wh]
## only select the portions where we need to need for our project

colnames(wh_use)[1] <- "country_name"
## change col name for eaier merge

total=merge(vdem_use, wh_use, by = c("country_name", "year"),
            all.x=TRUE,
            all.y=TRUE) 
##merge data
```
  
```{r clean-data}
#| message: false
#| warning: false
# Select the time range from 2019 only 
total_2019 <- total[total$year == 2019,]

#replace missing values in each numeric column with median value of column
total_2019 <- total_2019 %>% 
  mutate(across(where(is.numeric),~replace_na(.,median(.,na.rm=TRUE))))

# removing coup and civil war because it was all NA or 0 for 2019
total_2019 <- total_2019 %>% select(-one_of("civil_war", "coup"))

# changes names to shorter and easier to type/remember forms
cs <- total_2019 %>% rename(csrepress = v2csreprss, civil_war = e_civil_war, 
                           coup = e_pt_coup,
                           edu = e_peaveduc, corr = v2x_corr, 
                           cspart = v2x_cspart, 
                           cs_index = v2xcs_ccsi, 
                           social_support = 'Social support', 
                           choices = 'Freedom to make life choices', 
                           gen = Generosity,
                           region = e_regionpol,
                           happ = "Life Ladder", 
                           lifee = "Healthy life expectancy at birth", 
                           gdp = "Log GDP per capita")
```

```{r import-data}
# import data
cs_full <- readRDS("/cloud/project/data/civil_society")
# get only 2019 and remove civil war and coup because there are none in 2019
cs <- cs_full %>% subset(year == 2019) %>% 
        select(-one_of("civil_war", "coup")) %>% drop_na()
```

```{r region-tidying}
# sets as factor
cs$region <- as.factor(cs$region)

# We choose Sub Saharan Africa as the reference level
# We are interested in how all regions differ from one another
# We are not focused on only one specific region so we did not intentionally
# choose Sub Saharan Africa
cs$region <- relevel(cs$region, ref = 4)

# creates new data frame for tree plotting with regions as numbers still
cs_num <- cs

# recodes region to be the region it represents rather than a number value/code
levels(cs$region) <- c('SubSaharanAfrica',
                    'EasternEurope_PostSovietUnion', 
                    'LatinAmerica',
                    'NorthAfrica_MiddleEast',
                    'WesternEurope_NorthAmerica',
                    'EasternAsia',
                    'SouthEasternAsia',
                    'SouthernAsia',
                    'ThePacific',
                    'TheCarribean')
```

# Intro to Slides with Quarto (Delete This Section for Final Presentation!)

## New Slides {.smaller}

- `#` in the text editor creates a *section* header slide, with text in the 
centered in the middle of the slide
- `##` in the text editor creates a *new slide*: the text next to the `##` 
is the title of the slide
- Note also (which you can only see in the `.qmd`) that the `{.smaller}`
code next to a slide title makes the text of that slide smaller (compare the
text size of this slide to the text size in the next slide)

## Bulleted Lists 

- You can use `-` in the text editor to make bulleted lists
- If you want to have bullet points appear click-by-click, you can 
use the **incremental** div:
```
:::{.incremental}
- these bullet points
- will appear click by click
:::
```

## Slide with Columns 

::::{.columns}

:::{.column width=50%}
Column 1
:::

:::{.column width=50%}
Column 2
:::


::::

## Bulleted Lists Click-By-Click Example

:::{.incremental}
- these bullet points
- will appear click-by-click
:::

## Embedding R Code

- Embedding R code works just like in regular Quarto, using R chunks

```{r}
#| echo: true
mtcars
```

## Visualization

```{r}
#| echo: true
library(tidyverse)
ggplot(mtcars, aes(x = mpg, y = wt)) +
  geom_point()
```

## Customization

- You can change the default aesthetic of your slide show by 
changing the *theme* by using the `theme` YAML option (you have to add it 
in the `revealjs` section, beneath `embed-resources`)
- See [here](https://quarto.org/docs/presentations/revealjs/themes.html) for 
the themes you can use (and adapt - you can also make your own if
you want, see the instructions in the linked page)
- Theme names are put in "quotes"

## Resources

- You find Quarto revealjs documentation [here](https://quarto.org/docs/presentations/revealjs/)
- Meghan Hall also has a [page](https://meghan.rbind.io/blog/quarto-slides/) 
with useful tips

# Presentation Template

## Note

- You do not have to use this format exactly!
- Presentations should be roughly 7 minutes
- Each group member should speak for an equal amount of time
- You can separate sections with section slides but do not have to

## Introduction to Topic and Motivation
:::{.incremental}
- Learn about civil society's place in our overall society and relate to our lives
- Civil Society is...
- Political and Social perspective
- The presence of more social cohesive factors--such as region, presence of war, social support, and civil society index--will have strong influences on civil society participation
- Specific focus on 2019 because it is pre-covid 
:::
:::{.notes}
be sure to expand on why we chose it briefly and what civil society is
:::


## Introduction to Data
:::{.incremental}
- Data is from the VDEM Group and the World Happiness Index
- We selected variables we thought would relate to civil society, such as social support and GDP
- NAs were replaced with the median value 
- Region was modified to a factor with regional names
- Variables were scaled for regression models
- Civil war and coup were dropped because there were no instances in 2019
:::

::: {.notes}
list some variables when talking about how we chose them
say why NAs were replaced with median briefly
note that variables were scaled because of the wide range (0-1 vs 1-10 etc)
:::

## Highlights from EDA 1: By Region
:::{.incremental}
```{r variable-visualization-1}
#| warning: false
#| message: false
# A scatter plot to show the relationship between civil society participation 
# and social support by region

# Reformat the legend
# Custom labels for color legend with text wrapping
custom_labels <-            c("Sub-Saharan Africa",
                              "Eastern European- Post Soviet Union",
                              "Latin America",
                              "North Africa- Middle East",
                              "Western Europe- North America",
                              "Eastern Asia",
                              "South Eastern Asia",
                              "Southern Asia",
                              "The Pacific",
                              "The Caribbean")

viz1 <- ggplot(cs, aes(x=social_support, 
               y = cspart,
               color = region)) + 
  geom_jitter() +
  geom_smooth(method = 'lm', aes(group = 1)) + 
  labs(x = "Social Support",
       y = "Civil Society Participation") +
  theme(legend.position = "none")

# A scatterplot to show the relationship between civil society participation 
# and participation in democracy by region
viz2 <- ggplot(cs, aes(x=v2x_partipdem, 
               y = cspart,
               color = region)) + 
  geom_point() +
  geom_smooth(method = 'lm', aes(group = 1)) +
  labs(x = str_wrap("Participation in Democracy",25),
       y = "Civil Society Participation") + 
  theme(legend.position = "bottom") +
  theme(legend.key.size = unit(.2, 'cm'), legend.title = element_text(size=11),
        legend.text = element_text(size=11))

# A scatterplot to show the relationship between civil society participation 
# and civil society index by region
viz3 <- ggplot(cs, aes(x=cs_index, 
               y = cspart,
               color = region)) + 
  geom_point() +
  geom_smooth(method = 'lm', aes(group = 1)) + 
  labs(x = "Civil Society Index",
       y = "Civil Society Participation", 
       color = "Region") +
  theme(legend.position = "none") + 
  scale_color_discrete(labels = c("Sub-Saharan Africa",
                              str_wrap("Eastern European- Post Soviet Union", 20),
                              "Latin America",
                              str_wrap("North Africa- Middle East", 13),
                              str_wrap("Western Europe- North America", 15),
                              "Eastern Asia",
                              "South Eastern Asia",
                              "Southern Asia",
                              "The Pacific",
                              "The Caribbean"))

## Note that when rendered these three are too squished to be read. 
## might be better to just do them all on their own?
viz1 + viz2 + viz3 + 
  plot_annotation(title = 
  "Civil Society Participation vs. Hypothesized Key Predictors by Region")
```
:::

::: {.notes}
list some variables when talking about how we chose them
say why NAs were replaced with median briefly
note that variables were scaled because of the wide range (0-1 vs 1-10 etc)
:::

## Highlights from EDA 2: Social Predictors
```{r variable-visualization}

```
- Social support has a complex relationship 
- Participation in democracy and civil society index appear more linear
- mention any trends by region (not sure what there is)

::: {.notes}
talk about the relationships present, the right two being somewhat linear but social support has a more complex relationship, just something we needed to keep in mind
tried transforming social support but we didn't find a way to make it more linear
:::

:::{.notes}
need to add the proper tables with the p values and nice formatting 
:::
```{r test-train-split, echo = FALSE}
# 70, 30 test train split
set.seed(145)
train <- sample(c(TRUE, FALSE), nrow(cs), replace = TRUE, prob=c(.7,.3))
test <- (!train)
val <- test
```

## Regression
```{r matrix-creation, echo=FALSE}
# create x and y for glmnet
set.seed(129)
x <- model.matrix(cspart ~ csrepress+v2x_partipdem+edu+corr+cs_index+
                           social_support+choices+gen+region+lifee+happ+gdp, 
                  data = cs)[, -1]
y <- cs$cspart
```
::::{.columns}

:::{.column width=50%}
Ridge
- Minimizes the effect of non-influential variables
- hypertuning lambda with CV
```{r ridge-regression}
# set seed for reproducibility
set.seed(129)

# cross validation for best l
cv_r <- cv.glmnet(x[train,], y[train], alpha = 0, 
                  # scale the x values 
                  lambda = 10^seq(10, -2, length = 100), scale = TRUE)

# saving optimal lambda
bestlam_r <- cv_r$lambda.min

# calculating MSE
ridge_pred <- predict(cv_r, s = bestlam_r,
newx = x[test, ], scale = TRUE)
ridge_mse <- mean((ridge_pred - y[test])^2)

# fits final ridge model
ridge_mod <- glmnet(x, y, alpha = 0, lambda = bestlam_r, scale = TRUE)

# saves coefficients
coef_r <-coef(ridge_mod)

# prints important coefficients as a table
ridge_feature_estimate <- ridge_mod %>% tidy() %>%
  select(term, estimate)
ridge_feature_estimate_ordered <- ridge_feature_estimate %>% 
  arrange(desc(abs(estimate)))
print(ridge_feature_estimate_ordered)
``` 
:::

:::{.column width=50%}
Lasso 
- Zeros out non-influential variables
- hypertuning of lambda from CV
```{r lasso-regression}
# set seed for reproducibility
set.seed(18)
 
# cross validation for best l
cv_l <- cv.glmnet(x[train,], y[train], alpha = 1,
lambda = 10^seq(10, -2, length = 100), scale = TRUE)

# saving optimal lambda
bestlam_l <- cv_l$lambda.min

# calculating MSE
lasso_pred <- predict(cv_l, s = bestlam_l,
# scale x values
newx = x[test, ], scale = TRUE)
lasso_mse <- mean((lasso_pred - y[test])^2)

# fits model
lasso_mod <- glmnet(x, y, lambda = bestlam_l, scale = TRUE)

# saves coefficients
coef_l <-coef(lasso_mod)

# prints important coefficients as a table
lasso_feature_estimate <- lasso_mod %>% tidy() %>%
  select(term, estimate)
lasso_feature_estimate_ordered <- lasso_feature_estimate %>% 
  arrange(desc(abs(estimate)))

print(lasso_feature_estimate_ordered)
```
:::


::::


## Tree Methods
```{r tree_method}
# code is attributed to LACOL summer course
# instructors and ISLR authors
format_tree_labels <- function(labels, levels) {
  sapply(labels, \(x) if(grepl(":", x)) clean_col(x, levels) else clean_lt(x))
} 

# replace letter positions with actual level labels
clean_col <- function(x, levels){
  # split the label into label and levels
  x <- str_split_1(x, ":")
  # make new temp objects for the two components
  var <- x[1]
  levs_ids <- x[2]
  # get levels for correct variable
  levs <- levels[[var]]
  # get level ids for *relevant* levels
  levs_ids <- str_split_1(levs_ids, "") 
  levs_ids <- sapply(levs_ids, \(x) which(letters == x))
  # cut down levs to only the required levels
  levs <- levs[levs_ids]
  # paste everything together and return (immplicitly)
  paste0(var, ": ", paste0(levs, collapse = ", "))
}

# space out labels that include only "<"
clean_lt <- function(x){
  # split on <, then recombine with spaces before and after <
  x <- str_split_1(x, "<")
  paste0(x, collapse = " < ")
}

plot_tree <- function(model){
  require(ggdendro)
  # extract necessary information from tree object so that it is ggplotable
  tree_data <- dendro_data(model)
  # create a data frame with the split *values* which dendro_data() doesn't extract
  frame <- model$frame %>%
    rownames_to_column(var = "split") %>%
    mutate(splits = as.data.frame(splits)) %>% 
    unnest(cols = c(splits)) %>% 
    filter(var != "<leaf>") %>% 
    select(cutleft)
  
  # add the splits information in, which dendro_data() misses
  tree_data$labels <- tree_data$labels %>% 
    bind_cols(frame) %>% 
    mutate(label = paste0(as.character(label), cutleft),
           label = format_tree_labels(label, attr(model, "xlevels")))
      
  ggplot(segment(tree_data)) +
    geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) +
    geom_text(data = label(tree_data), 
              aes(x = x, y = y, label = label), vjust = -0.5, size = 3) +
    geom_text(data = leaf_label(tree_data), 
              aes(x = x, y = y, label = label), vjust = 1.5, size = 2) +
    theme_dendro()
}

```
::::{.columns}

:::{.column width=50%}
Single Decision Tree
```{r tree-method}
# sets set for reproducibility
set.seed(247) 

# creates tree on training data
tree_train <- tree(cspart ~ . -year -country_name, cs_num,
    subset = train)

# cross validation of tree
cv_train <- cv.tree(tree_train)

# pruning to 8 nodes per CV results
prune_train <- prune.tree(tree_train, best = 8)

# plots pruned tree
treePlot <- plot_tree(prune_train) + 
  labs(title = "Pruned Tree Plot",
       caption = 'Regions 1, 2, 3, 7, and 9 represent Eastern Europe & Post
       Soviet Union, Latin America, North Africa and Middle East, South Eastern 
       Asia, and the Pacific') + 
  # Center the plot title
  theme(plot.title = element_text(hjust = 0.4))

# gets predictions and test values for mse
tree_pred_tuned <- predict(prune_train, cs_num[test,],
    type = "vector")
y_test <- y[test]

# gets mse for pruned tree
mse <- mean((tree_pred_tuned - y_test)^2)

treePlot
```
:::{.notes}
The single decision tree plots the relationship between the most important predictors and the outcome. We can see that civil society index is the most influential as it is the topmost node of the tree. From there, participation in democracy and regions 1, 2, 3, 7, and 9, which represent Eastern Europe & Post Soviet Union, Latin America, North Africa and Middle East, South Eastern Asia, and the Pacific, were also identified as the most influential predictors in this model when predicting civil society participation. 

tree
- Visualize importance and relationships between variables and outcome
- Greedy method--may be less generalizable
- CV for number of terminal nodes


random
- Relative variable importances
- CV for number of considered parameters
- More accurate than tree methods
:::
:::

:::{.column width=50%}
Random Forests
```{r random-forests}
# sets seed for reproducibility
set.seed(286)

# sets cv parameters
train_control <- trainControl(method="cv", number = 5)

# gets grid for mtry
tune_grid <- expand.grid(mtry = 3:12)

# does training
best_forest <- train(cspart ~ . -year -country_name, data = cs[train,], 
                     trControl = train_control, 
                     method="rf", 
                     tuneGrid = tune_grid,
                     verbose = FALSE)

# gets test for y
y_test <- y[test]

# predictions for test set with optimal mtry of 9
rf_cs <- randomForest(cspart ~ . -year -country_name, data = cs[train,], 
                       mtry = 9, importance = TRUE)

yhat_rf <- predict(rf_cs, newdata = cs[test,])

# calculates MSE
rf_mse <- mean((yhat_rf - y_test)^2)

# importances
importances_cs <- importance(rf_cs) %>% 
  as_tibble(rownames = "Variable")

importances_cs
```
:::

::::

## Model Comparison
- Random forests was the most effective model of for the data
- Lowest MSE and highest R2
```{r model-comp}
#| warning: false
# note: I think we are planning to cut this because
# interpretation-wise it doesn't add much that the MSE doesn't
# already cover. 

# putting together data of predicted, actual, and model type
dataplot <- data.frame(true_value = c(y[test], y[test], y[test], y[test]))
dataplot$model_type <- c(rep("Lasso", length(lasso_pred)), rep("Ridge Model", 
            length(ridge_pred)), rep("Tree Model", length(tree_pred_tuned)), 
            rep('Random Forests', length(yhat_rf)))
dataplot$predictions <- c(lasso_pred, ridge_pred, tree_pred_tuned, yhat_rf)

# function giving us R2
r2 <- function(predicted, y) {
  #find SST and SSE
  sst <- sum((y - mean(y))^2)
  sse <- sum((predicted - y)^2)
  #find R-Squared
  rsq <- 1 - sse/sst
}

# setting up values for graph
name=c("Tree","Random Forest", "Lasso","Ridge")
mse_all=c(mse, rf_mse, lasso_mse, ridge_mse)
value=c(r2(tree_pred_tuned, y[test]), r2(yhat_rf, y[test]), 
        r2(lasso_pred, y[test]), r2(ridge_pred, y[test]))

# putting into table
compare_data=tibble(name,mse_all,value)

# table of scores because differences may be hard to tell from graph
model_comp <- tibble('Model' = name, 
                     'MSE' = mse_all,
                     'R-Squared' = value)
```
## Conclusions & Future Work
:::{.incremental}
- Civil society index, participation in democracy, and region
- Random forests was our most effective model
```{r table}
# prints table
model_comp
```
- Mostly supports our hypothesis
- Further research: interactions, beyond 2019
:::
:::{.notes}
reflection on limitations is 5 points so be sure to really hit on that
be sure to expand the points!!
:::
